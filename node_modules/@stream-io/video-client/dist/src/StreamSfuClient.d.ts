import type { WebSocket } from 'ws';
import type { FinishedUnaryCall } from '@protobuf-ts/runtime-rpc';
import { Dispatcher, IceTrickleBuffer } from './rtc';
import { JoinRequest, SfuRequest } from './gen/video/sfu/event/events';
import { ICERestartRequest, SendAnswerRequest, SendStatsRequest, SetPublisherRequest, TrackSubscriptionDetails, UpdateMuteStatesRequest } from './gen/video/sfu/signal_rpc/signal';
import { ICETrickle, TrackType } from './gen/video/sfu/models/models';
import { SFUResponse } from './gen/coordinator';
export type StreamSfuClientConstructor = {
    /**
     * The event dispatcher instance to use.
     */
    dispatcher: Dispatcher;
    /**
     * The SFU server to connect to.
     */
    sfuServer: SFUResponse;
    /**
     * The JWT token to use for authentication.
     */
    token: string;
    /**
     * An optional `sessionId` to use for the connection.
     * If not provided, a random UUIDv4 will be generated.
     */
    sessionId?: string;
};
/**
 * The client used for exchanging information with the SFU.
 */
export declare class StreamSfuClient {
    /**
     * A buffer for ICE Candidates that are received before
     * the PeerConnections are ready to handle them.
     */
    readonly iceTrickleBuffer: IceTrickleBuffer;
    /**
     * The `sessionId` of the currently connected participant.
     */
    readonly sessionId: string;
    /**
     * The `edgeName` representing the edge the client is connected to.
     */
    readonly edgeName: string;
    /**
     * The current token used for authenticating against the SFU.
     */
    readonly token: string;
    /**
     * The SFU server details the current client is connected to.
     */
    readonly sfuServer: SFUResponse;
    /**
     * Holds the current WebSocket connection to the SFU.
     */
    signalWs: WebSocket;
    /**
     * Promise that resolves when the WebSocket connection is ready (open).
     */
    signalReady: Promise<WebSocket>;
    /**
     * A flag indicating whether the client is currently migrating away
     * from this SFU.
     */
    isMigratingAway: boolean;
    /**
     * A flag indicating that the client connection is broken for the current
     * client and that a fast-reconnect with a new client should be attempted.
     */
    isFastReconnecting: boolean;
    private readonly rpc;
    private keepAliveInterval?;
    private connectionCheckTimeout?;
    private pingIntervalInMs;
    private unhealthyTimeoutInMs;
    private lastMessageTimestamp?;
    private readonly unsubscribeIceTrickle;
    private readonly logger;
    /**
     * The normal closure code. Used for controlled shutdowns.
     */
    static NORMAL_CLOSURE: number;
    /**
     * The error code used when the SFU connection is unhealthy.
     * Usually, this means that no message has been received from the SFU for
     * a certain amount of time (`connectionCheckTimeout`).
     */
    static ERROR_CONNECTION_UNHEALTHY: number;
    /**
     * The error code used when the SFU connection is broken.
     * Usually, this means that the WS connection has been closed unexpectedly.
     * This error code is used to announce a fast-reconnect.
     */
    static ERROR_CONNECTION_BROKEN: number;
    /**
     * Constructs a new SFU client.
     *
     * @param dispatcher the event dispatcher to use.
     * @param sfuServer the SFU server to connect to.
     * @param token the JWT token to use for authentication.
     * @param sessionId the `sessionId` of the currently connected participant.
     */
    constructor({ dispatcher, sfuServer, token, sessionId, }: StreamSfuClientConstructor);
    close: (code: number, reason: string) => void;
    updateSubscriptions: (subscriptions: TrackSubscriptionDetails[]) => Promise<FinishedUnaryCall<import("./gen/video/sfu/signal_rpc/signal").UpdateSubscriptionsRequest, import("./gen/video/sfu/signal_rpc/signal").UpdateSubscriptionsResponse>>;
    setPublisher: (data: Omit<SetPublisherRequest, 'sessionId'>) => Promise<FinishedUnaryCall<SetPublisherRequest, import("./gen/video/sfu/signal_rpc/signal").SetPublisherResponse>>;
    sendAnswer: (data: Omit<SendAnswerRequest, 'sessionId'>) => Promise<FinishedUnaryCall<SendAnswerRequest, import("./gen/video/sfu/signal_rpc/signal").SendAnswerResponse>>;
    iceTrickle: (data: Omit<ICETrickle, 'sessionId'>) => Promise<FinishedUnaryCall<ICETrickle, import("./gen/video/sfu/signal_rpc/signal").ICETrickleResponse>>;
    iceRestart: (data: Omit<ICERestartRequest, 'sessionId'>) => Promise<FinishedUnaryCall<ICERestartRequest, import("./gen/video/sfu/signal_rpc/signal").ICERestartResponse>>;
    updateMuteState: (trackType: TrackType, muted: boolean) => Promise<FinishedUnaryCall<UpdateMuteStatesRequest, import("./gen/video/sfu/signal_rpc/signal").UpdateMuteStatesResponse>>;
    updateMuteStates: (data: Omit<UpdateMuteStatesRequest, 'sessionId'>) => Promise<FinishedUnaryCall<UpdateMuteStatesRequest, import("./gen/video/sfu/signal_rpc/signal").UpdateMuteStatesResponse>>;
    sendStats: (stats: Omit<SendStatsRequest, 'sessionId'>) => Promise<FinishedUnaryCall<SendStatsRequest, import("./gen/video/sfu/signal_rpc/signal").SendStatsResponse>>;
    startNoiseCancellation: () => Promise<FinishedUnaryCall<import("./gen/video/sfu/signal_rpc/signal").StartNoiseCancellationRequest, import("./gen/video/sfu/signal_rpc/signal").StartNoiseCancellationResponse>>;
    stopNoiseCancellation: () => Promise<FinishedUnaryCall<import("./gen/video/sfu/signal_rpc/signal").StopNoiseCancellationRequest, import("./gen/video/sfu/signal_rpc/signal").StopNoiseCancellationResponse>>;
    join: (data: Omit<JoinRequest, 'sessionId' | 'token'>) => Promise<void>;
    send: (message: SfuRequest) => Promise<void>;
    private keepAlive;
    private scheduleConnectionCheck;
}
