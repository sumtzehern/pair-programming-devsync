import { Observable } from 'rxjs';
import type { Patch } from './rxUtils';
import { StreamVideoParticipant, StreamVideoParticipantPatch, StreamVideoParticipantPatches } from '../types';
import { CallStatsReport } from '../stats';
import { CallIngressResponse, CallResponse, CallSessionResponse, CallSettingsResponse, EgressResponse, MemberResponse, OwnCapability, ThumbnailResponse, UserResponse, WSEvent } from '../gen/coordinator';
import { Pin } from '../gen/video/sfu/models/models';
import { Comparator } from '../sorting';
/**
 * Represents the state of the current call.
 */
export declare enum CallingState {
    /**
     * The call is in an unknown state.
     */
    UNKNOWN = "unknown",
    /**
     * The call is in an idle state.
     */
    IDLE = "idle",
    /**
     * The call is in the process of ringing.
     * (User hasn't accepted nor rejected the call yet.)
     */
    RINGING = "ringing",
    /**
     * The call is in the process of joining.
     */
    JOINING = "joining",
    /**
     * The call is currently active.
     */
    JOINED = "joined",
    /**
     * The call has been left.
     */
    LEFT = "left",
    /**
     * The call is in the process of reconnecting.
     */
    RECONNECTING = "reconnecting",
    /**
     * The call is in the process of migrating from one node to another.
     */
    MIGRATING = "migrating",
    /**
     * The call has failed to reconnect.
     */
    RECONNECTING_FAILED = "reconnecting-failed",
    /**
     * The call is in offline mode.
     */
    OFFLINE = "offline"
}
/**
 * Holds the state of the current call.
 * @react You don't have to use this class directly, as we are exposing the state through Hooks.
 */
export declare class CallState {
    private backstageSubject;
    private blockedUserIdsSubject;
    private createdAtSubject;
    private endedAtSubject;
    private startsAtSubject;
    private updatedAtSubject;
    private createdBySubject;
    private customSubject;
    private egressSubject;
    private ingressSubject;
    private recordingSubject;
    private sessionSubject;
    private settingsSubject;
    private transcribingSubject;
    private endedBySubject;
    private thumbnailsSubject;
    private membersSubject;
    private ownCapabilitiesSubject;
    private callingStateSubject;
    private startedAtSubject;
    private participantCountSubject;
    private anonymousParticipantCountSubject;
    private participantsSubject;
    private callStatsReportSubject;
    /**
     * The time the call session actually started.
     * Useful for displaying the call duration.
     */
    startedAt$: Observable<Date | undefined>;
    /**
     * The server-side counted number of participants connected to the current call.
     * This number includes the anonymous participants as well.
     */
    participantCount$: Observable<number>;
    /**
     * The server-side counted number of anonymous participants connected to the current call.
     * This number excludes the regular participants.
     */
    anonymousParticipantCount$: Observable<number>;
    /**
     * All participants of the current call (this includes the current user and other participants as well).
     */
    participants$: Observable<StreamVideoParticipant[]>;
    /**
     * Remote participants of the current call (this includes every participant except the logged-in user).
     */
    remoteParticipants$: Observable<StreamVideoParticipant[]>;
    /**
     * The local participant of the current call (the logged-in user).
     */
    localParticipant$: Observable<StreamVideoParticipant | undefined>;
    /**
     * Pinned participants of the current call.
     */
    pinnedParticipants$: Observable<StreamVideoParticipant[]>;
    /**
     * The currently elected dominant speaker in the current call.
     */
    dominantSpeaker$: Observable<StreamVideoParticipant | undefined>;
    /**
     * Emits true whenever there is an active screen sharing session within
     * the current call. Useful for displaying a "screen sharing" indicator and
     * switching the layout to a screen sharing layout.
     *
     * The actual screen sharing track isn't exposed here, but can be retrieved
     * from the list of call participants. We also don't want to be limiting
     * to the number of share screen tracks are displayed in a call.
     */
    hasOngoingScreenShare$: Observable<boolean>;
    /**
     * The latest stats report of the current call.
     * When stats gathering is enabled, this observable will emit a new value
     * at a regular (configurable) interval.
     *
     * Consumers of this observable can implement their own batching logic
     * in case they want to show historical stats data.
     */
    callStatsReport$: Observable<CallStatsReport | undefined>;
    /**
     * The list of members in the current call.
     */
    members$: Observable<MemberResponse[]>;
    /**
     * The list of capabilities of the current user.
     */
    ownCapabilities$: Observable<OwnCapability[]>;
    /**
     * The calling state.
     */
    callingState$: Observable<CallingState>;
    /**
     * The backstage state.
     */
    backstage$: Observable<boolean>;
    /**
     * Will provide the list of blocked user IDs.
     */
    blockedUserIds$: Observable<string[]>;
    /**
     * Will provide the time when this call has been created.
     */
    createdAt$: Observable<Date>;
    /**
     * Will provide the time when this call has been ended.
     */
    endedAt$: Observable<Date | undefined>;
    /**
     * Will provide the time when this call has been scheduled to start.
     */
    startsAt$: Observable<Date | undefined>;
    /**
     * Will provide the time when this call has been updated.
     */
    updatedAt$: Observable<Date>;
    /**
     * Will provide the user who created this call.
     */
    createdBy$: Observable<UserResponse | undefined>;
    /**
     * Will provide the custom data of this call.
     */
    custom$: Observable<Record<string, any>>;
    /**
     * Will provide the egress data of this call.
     */
    egress$: Observable<EgressResponse | undefined>;
    /**
     * Will provide the ingress data of this call.
     */
    ingress$: Observable<CallIngressResponse | undefined>;
    /**
     * Will provide the recording state of this call.
     */
    recording$: Observable<boolean>;
    /**
     * Will provide the session data of this call.
     */
    session$: Observable<CallSessionResponse | undefined>;
    /**
     * Will provide the settings of this call.
     */
    settings$: Observable<CallSettingsResponse | undefined>;
    /**
     * Will provide the transcribing state of this call.
     */
    transcribing$: Observable<boolean>;
    /**
     * Will provide the user who ended this call.
     */
    endedBy$: Observable<UserResponse | undefined>;
    /**
     * Will provide the thumbnails of this call.
     */
    thumbnails$: Observable<ThumbnailResponse | undefined>;
    readonly logger: import("../..").Logger;
    /**
     * A list of comparators that are used to sort the participants.
     *
     * @private
     */
    private sortParticipantsBy;
    private readonly eventHandlers;
    /**
     * Creates a new instance of the CallState class.
     *
     */
    constructor();
    /**
     * Sets the list of criteria that are used to sort the participants.
     * To disable sorting, you can pass `noopComparator()`.
     *
     * @param comparator the comparator to use to sort the participants.
     */
    setSortParticipantsBy: (comparator: Comparator<StreamVideoParticipant>) => void;
    /**
     * Gets the current value of an observable, or undefined if the observable has
     * not emitted a value yet.
     *
     * @param observable$ the observable to get the value from.
     */
    getCurrentValue: <T>(observable$: Observable<T>) => T;
    /**
     * Updates the value of the provided Subject.
     * An `update` can either be a new value or a function which takes
     * the current value and returns a new value.
     *
     * @internal
     *
     * @param subject the subject to update.
     * @param update the update to apply to the subject.
     * @return the updated value.
     */
    setCurrentValue: <T>(subject: import("rxjs").Subject<T>, update: Patch<T>) => T;
    /**
     * The server-side counted number of participants connected to the current call.
     * This number includes the anonymous participants as well.
     */
    get participantCount(): number;
    /**
     * Sets the number of participants in the current call.
     *
     * @internal
     * @param count the number of participants.
     */
    setParticipantCount: (count: Patch<number>) => number;
    /**
     * The time the call session actually started.
     * Useful for displaying the call duration.
     */
    get startedAt(): Date | undefined;
    /**
     * Sets the time the call session actually started.
     *
     * @internal
     * @param startedAt the time the call session actually started.
     */
    setStartedAt: (startedAt: Patch<Date | undefined>) => Date | undefined;
    /**
     * The server-side counted number of anonymous participants connected to the current call.
     * This number includes the anonymous participants as well.
     */
    get anonymousParticipantCount(): number;
    /**
     * Sets the number of anonymous participants in the current call.
     *
     * @internal
     * @param count the number of anonymous participants.
     */
    setAnonymousParticipantCount: (count: Patch<number>) => number;
    /**
     * The list of participants in the current call.
     */
    get participants(): StreamVideoParticipant[];
    /**
     * Sets the list of participants in the current call.
     *
     * @internal
     *
     * @param participants the list of participants.
     */
    setParticipants: (participants: Patch<StreamVideoParticipant[]>) => StreamVideoParticipant[];
    /**
     * The local participant in the current call.
     */
    get localParticipant(): StreamVideoParticipant | undefined;
    /**
     * The list of remote participants in the current call.
     */
    get remoteParticipants(): StreamVideoParticipant[];
    /**
     * The dominant speaker in the current call.
     */
    get dominantSpeaker(): StreamVideoParticipant | undefined;
    /**
     * The list of pinned participants in the current call.
     */
    get pinnedParticipants(): StreamVideoParticipant[];
    /**
     * Tell if there is an ongoing screen share in this call.
     */
    get hasOngoingScreenShare(): boolean;
    /**
     * The calling state.
     */
    get callingState(): CallingState;
    /**
     * Sets the calling state.
     *
     * @internal
     * @param state the new calling state.
     */
    setCallingState: (state: Patch<CallingState>) => CallingState;
    /**
     * The call stats report.
     */
    get callStatsReport(): CallStatsReport | undefined;
    /**
     * Sets the call stats report.
     *
     * @internal
     * @param report the report to set.
     */
    setCallStatsReport: (report: Patch<CallStatsReport | undefined>) => CallStatsReport | undefined;
    /**
     * The members of the current call.
     */
    get members(): MemberResponse[];
    /**
     * Sets the members of the current call.
     *
     * @internal
     * @param members the members to set.
     */
    setMembers: (members: Patch<MemberResponse[]>) => void;
    /**
     * The capabilities of the current user for the current call.
     */
    get ownCapabilities(): OwnCapability[];
    /**
     * Sets the own capabilities.
     *
     * @internal
     * @param capabilities the capabilities to set.
     */
    setOwnCapabilities: (capabilities: Patch<OwnCapability[]>) => OwnCapability[];
    /**
     * The backstage state.
     */
    get backstage(): boolean;
    /**
     * Will provide the list of blocked user IDs.
     */
    get blockedUserIds(): string[];
    /**
     * Will provide the time when this call has been created.
     */
    get createdAt(): Date;
    /**
     * Will provide the time when this call has been ended.
     */
    get endedAt(): Date | undefined;
    /**
     * Will provide the time when this call has been scheduled to start.
     */
    get startsAt(): Date | undefined;
    /**
     * Will provide the time when this call has been updated.
     */
    get updatedAt(): Date;
    /**
     * Will provide the user who created this call.
     */
    get createdBy(): UserResponse | undefined;
    /**
     * Will provide the custom data of this call.
     */
    get custom(): Record<string, any>;
    /**
     * Will provide the egress data of this call.
     */
    get egress(): EgressResponse | undefined;
    /**
     * Will provide the ingress data of this call.
     */
    get ingress(): CallIngressResponse | undefined;
    /**
     * Will provide the recording state of this call.
     */
    get recording(): boolean;
    /**
     * Will provide the session data of this call.
     */
    get session(): CallSessionResponse | undefined;
    /**
     * Will provide the settings of this call.
     */
    get settings(): CallSettingsResponse | undefined;
    /**
     * Will provide the transcribing state of this call.
     */
    get transcribing(): boolean;
    /**
     * Will provide the user who ended this call.
     */
    get endedBy(): UserResponse | undefined;
    /**
     * Will provide the thumbnails of this call, if enabled in the call settings.
     */
    get thumbnails(): ThumbnailResponse | undefined;
    /**
     * Will try to find the participant with the given sessionId in the current call.
     *
     * @param sessionId the sessionId of the participant to find.
     * @returns the participant with the given sessionId or undefined if not found.
     */
    findParticipantBySessionId: (sessionId: string) => StreamVideoParticipant | undefined;
    /**
     * Returns a new lookup table of participants indexed by their session ID.
     */
    getParticipantLookupBySessionId: () => {
        [sessionId: string]: StreamVideoParticipant | undefined;
    };
    /**
     * Updates a participant in the current call identified by the given `sessionId`.
     * If the participant can't be found, this operation is no-op.
     *
     * @internal
     *
     * @param sessionId the session ID of the participant to update.
     * @param patch the patch to apply to the participant.
     * @returns the updated participant or `undefined` if the participant couldn't be found.
     */
    updateParticipant: (sessionId: string, patch: Partial<StreamVideoParticipant> | ((p: StreamVideoParticipant) => StreamVideoParticipantPatch)) => StreamVideoParticipant[] | undefined;
    /**
     * Updates a participant in the current call identified by the given `sessionId`.
     * If a participant with matching `sessionId` can't be found, the provided
     * `participant` is added to the list of participants.
     *
     * @param sessionId the session ID of the participant to update.
     * @param participant the participant to update or add.
     */
    updateOrAddParticipant: (sessionId: string, participant: StreamVideoParticipant) => StreamVideoParticipant[];
    /**
     * Updates all participants in the current call whose session ID is in the given `sessionIds`.
     * If no patches are provided, this operation is no-op.
     *
     * @internal
     *
     * @param patch the patch to apply to the participants.
     * @returns all participants, with all patch applied.
     */
    updateParticipants: (patch: StreamVideoParticipantPatches) => StreamVideoParticipant[] | undefined;
    /**
     * Updates the call state with the data received from the server.
     *
     * @internal
     *
     * @param event the video event that our backend sent us.
     */
    updateFromEvent: (event: WSEvent) => void;
    /**
     * Updates the participant pinned state with server side pinning data.
     *
     * @param pins the latest pins from the server.
     */
    setServerSidePins: (pins: Pin[]) => StreamVideoParticipant[];
    /**
     * Updates the call state with the data received from the server.
     *
     * @internal
     *
     * @param call the call response from the server.
     */
    updateFromCallResponse: (call: CallResponse) => void;
    private updateFromMemberRemoved;
    private updateFromMemberAdded;
    private updateFromHLSBroadcastStopped;
    private updateFromHLSBroadcastingFailed;
    private updateFromHLSBroadcastStarted;
    private updateFromSessionParticipantLeft;
    private updateFromSessionParticipantJoined;
    private updateMembers;
    private updateParticipantReaction;
    private unblockUser;
    private blockUser;
    private updateOwnCapabilities;
}
