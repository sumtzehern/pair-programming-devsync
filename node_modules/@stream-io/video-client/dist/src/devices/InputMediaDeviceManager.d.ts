import { Observable } from 'rxjs';
import { Call } from '../Call';
import { InputMediaDeviceManagerState } from './InputMediaDeviceManagerState';
import { Logger } from '../coordinator/connection/types';
import { TrackType } from '../gen/video/sfu/models/models';
export type MediaStreamFilter = (stream: MediaStream) => Promise<MediaStream>;
export declare abstract class InputMediaDeviceManager<T extends InputMediaDeviceManagerState<C>, C = MediaTrackConstraints> {
    protected readonly call: Call;
    readonly state: T;
    protected readonly trackType: TrackType;
    /**
     * @internal
     */
    statusChangePromise?: Promise<void>;
    /**
     * if true, stops the media stream when call is left
     */
    stopOnLeave: boolean;
    logger: Logger;
    protected subscriptions: Function[];
    private isTrackStoppedDueToTrackEnd;
    private filters;
    private statusChangeAbortController?;
    protected constructor(call: Call, state: T, trackType: TrackType);
    /**
     * Lists the available audio/video devices
     *
     * Note: It prompts the user for a permission to use devices (if not already granted)
     *
     * @returns an Observable that will be updated if a device is connected or disconnected
     */
    listDevices(): Observable<MediaDeviceInfo[]>;
    /**
     * Starts stream.
     */
    enable(): Promise<void>;
    /**
     * Stops or pauses the stream based on state.disableMode
     * @param {boolean} [forceStop=false] when true, stops the tracks regardless of the state.disableMode
     */
    disable(forceStop?: boolean): Promise<void>;
    /**
     * If status was previously enabled, it will re-enable the device.
     */
    resume(): Promise<void>;
    /**
     * If the current device status is disabled, it will enable the device,
     * else it will disable it.
     */
    toggle(): Promise<void>;
    /**
     * Registers a filter that will be applied to the stream.
     *
     * The registered filter will get the existing stream, and it should return
     * a new stream with the applied filter.
     *
     * @param filter the filter to register.
     * @returns a function that will unregister the filter.
     */
    registerFilter(filter: MediaStreamFilter): Promise<() => Promise<void>>;
    /**
     * Will set the default constraints for the device.
     *
     * @param constraints the constraints to set.
     */
    setDefaultConstraints(constraints: C): void;
    /**
     * Selects a device.
     *
     * Note: This method is not supported in React Native
     * @param deviceId the device id to select.
     */
    select(deviceId: string | undefined): Promise<void>;
    /**
     * Disposes the manager.
     *
     * @internal
     */
    dispose: () => void;
    protected applySettingsToStream(): Promise<void>;
    protected abstract getDevices(): Observable<MediaDeviceInfo[]>;
    protected abstract getStream(constraints: C): Promise<MediaStream>;
    protected abstract publishStream(stream: MediaStream): Promise<void>;
    protected abstract stopPublishStream(stopTracks: boolean): Promise<void>;
    protected getTracks(): MediaStreamTrack[];
    protected muteStream(stopTracks?: boolean): Promise<void>;
    private muteTracks;
    private unmuteTracks;
    private stopTracks;
    private muteLocalStream;
    protected unmuteStream(): Promise<void>;
    private get mediaDeviceKind();
    private handleDisconnectedOrReplacedDevices;
    private findDeviceInList;
    private nextAbortableStatusChangeRequest;
    private resetStatusChangeRequest;
}
