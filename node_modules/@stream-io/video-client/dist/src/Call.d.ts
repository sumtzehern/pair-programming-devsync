import { Publisher, Subscriber } from './rtc';
import { TrackType } from './gen/video/sfu/models/models';
import { CallState } from './store';
import { AcceptCallResponse, BlockUserResponse, CollectUserFeedbackResponse, EndCallResponse, GetCallResponse, GetCallStatsResponse, GetOrCreateCallRequest, GetOrCreateCallResponse, GoLiveRequest, GoLiveResponse, ListRecordingsResponse, ListTranscriptionsResponse, MuteUsersResponse, PinRequest, PinResponse, QueryMembersRequest, QueryMembersResponse, RejectCallResponse, RequestPermissionRequest, RequestPermissionResponse, SendEventResponse, SendReactionRequest, SendReactionResponse, StartHLSBroadcastingResponse, StartRecordingRequest, StartRecordingResponse, StartTranscriptionRequest, StartTranscriptionResponse, StopHLSBroadcastingResponse, StopLiveResponse, StopRecordingResponse, StopTranscriptionResponse, UnblockUserResponse, UnpinRequest, UnpinResponse, UpdateCallMembersRequest, UpdateCallMembersResponse, UpdateCallRequest, UpdateCallResponse, UpdateUserPermissionsRequest, UpdateUserPermissionsResponse } from './gen/coordinator';
import { AudioTrackType, CallConstructor, CallLeaveOptions, DebounceType, JoinCallData, PublishOptions, SubscriptionChanges, TrackMuteType, VideoTrackType } from './types';
import { VideoLayerSetting } from './gen/video/sfu/event/events';
import { DynascaleManager } from './helpers/DynascaleManager';
import { PermissionsContext } from './permissions';
import { StreamClient } from './coordinator/connection/client';
import { CallEventListener, Logger } from './coordinator/connection/types';
import { CameraManager, MicrophoneManager, ScreenShareManager, SpeakerManager } from './devices';
/**
 * An object representation of a `Call`.
 */
export declare class Call {
    /**
     * The type of the call.
     */
    readonly type: string;
    /**
     * The ID of the call.
     */
    readonly id: string;
    /**
     * The call CID.
     */
    readonly cid: string;
    /**
     * The state of this call.
     */
    readonly state: CallState;
    /**
     * Flag indicating whether this call is "watched" and receives
     * updates from the backend.
     */
    watching: boolean;
    /**
     * Device manager for the camera
     */
    readonly camera: CameraManager;
    /**
     * Device manager for the microphone.
     */
    readonly microphone: MicrophoneManager;
    /**
     * Device manager for the speaker.
     */
    readonly speaker: SpeakerManager;
    /**
     * Device manager for the screen.
     */
    readonly screenShare: ScreenShareManager;
    /**
     * The DynascaleManager instance.
     */
    readonly dynascaleManager: DynascaleManager;
    subscriber?: Subscriber;
    publisher?: Publisher;
    /**
     * Flag telling whether this call is a "ringing" call.
     */
    private readonly ringingSubject;
    /**
     * The permissions context of this call.
     */
    readonly permissionsContext: PermissionsContext;
    readonly logger: Logger;
    /**
     * The event dispatcher instance dedicated to this Call instance.
     * @private
     */
    private readonly dispatcher;
    private trackSubscriptionsSubject;
    private statsReporter?;
    private sfuStatsReporter?;
    private dropTimeout;
    private readonly clientStore;
    readonly streamClient: StreamClient;
    private sfuClient?;
    private reconnectAttempts;
    private maxReconnectAttempts;
    private isLeaving;
    /**
     * A list hooks/functions to invoke when the call is left.
     * A typical use case is to clean up some global event handlers.
     * @private
     */
    private readonly leaveCallHooks;
    private readonly streamClientBasePath;
    private streamClientEventHandlers;
    /**
     * Constructs a new `Call` instance.
     *
     * NOTE: Don't call the constructor directly, instead
     * Use the [`StreamVideoClient.call`](./StreamVideoClient.md/#call)
     * method to construct a `Call` instance.
     */
    constructor({ type, id, streamClient, members, ownCapabilities, sortParticipantsBy, clientStore, ringing, watching, }: CallConstructor);
    private registerEffects;
    /**
     * You can subscribe to WebSocket events provided by the API. To remove a subscription, call the `off` method.
     * Please note that subscribing to WebSocket events is an advanced use-case.
     * For most use-cases, it should be enough to watch for state changes.
     *
     * @param eventName the event name.
     * @param fn the event handler.
     */
    on: <E extends import("./coordinator/connection/types").EventTypes | import("./rtc").SfuEventKinds>(eventName: E, fn: CallEventListener<E>) => () => void;
    /**
     * Remove subscription for WebSocket events that were created by the `on` method.
     *
     * @param eventName the event name.
     * @param fn the event handler.
     */
    off: <E extends import("./coordinator/connection/types").EventTypes | import("./rtc").SfuEventKinds>(eventName: E, fn: CallEventListener<E>) => void;
    /**
     * Leave the call and stop the media streams that were published by the call.
     */
    leave: ({ reject, reason, }?: CallLeaveOptions) => Promise<void>;
    /**
     * A flag indicating whether the call is "ringing" type of call.
     */
    get ringing(): boolean;
    /**
     * Retrieves the current user ID.
     */
    get currentUserId(): string | undefined;
    /**
     * A flag indicating whether the call was created by the current user.
     */
    get isCreatedByMe(): boolean;
    /**
     * Loads the information about the call.
     *
     * @param params.ring if set to true, a `call.ring` event will be sent to the call members.
     * @param params.notify if set to true, a `call.notification` event will be sent to the call members.
     * @param params.members_limit the total number of members to return as part of the response.
     */
    get: (params?: {
        ring?: boolean;
        notify?: boolean;
        members_limit?: number;
    }) => Promise<GetCallResponse>;
    /**
     * Loads the information about the call and creates it if it doesn't exist.
     *
     * @param data the data to create the call with.
     */
    getOrCreate: (data?: GetOrCreateCallRequest) => Promise<GetOrCreateCallResponse>;
    /**
     * Creates a call
     *
     * @param data the data to create the call with.
     */
    create: (data?: GetOrCreateCallRequest) => Promise<GetOrCreateCallResponse>;
    /**
     * A shortcut for {@link Call.get} with `ring` parameter set to `true`.
     * Will send a `call.ring` event to the call members.
     */
    ring: () => Promise<GetCallResponse>;
    /**
     * A shortcut for {@link Call.get} with `notify` parameter set to `true`.
     * Will send a `call.notification` event to the call members.
     */
    notify: () => Promise<GetCallResponse>;
    /**
     * Marks the incoming call as accepted.
     *
     * This method should be used only for "ringing" call flows.
     * {@link Call.join} invokes this method automatically for you when joining a call.
     * Unless you are implementing a custom "ringing" flow, you should not use this method.
     */
    accept: () => Promise<AcceptCallResponse>;
    /**
     * Marks the incoming call as rejected.
     *
     * This method should be used only for "ringing" call flows.
     * {@link Call.leave} invokes this method automatically for you when you leave or reject this call.
     * Unless you are implementing a custom "ringing" flow, you should not use this method.
     */
    reject: () => Promise<RejectCallResponse>;
    /**
     * Will start to watch for call related WebSocket events and initiate a call session with the server.
     *
     * @returns a promise which resolves once the call join-flow has finished.
     */
    join: (data?: JoinCallData) => Promise<void>;
    private waitForJoinResponse;
    /**
     * Starts publishing the given video stream to the call.
     * The stream will be stopped if the user changes an input device, or if the user leaves the call.
     *
     * Consecutive calls to this method will replace the previously published stream.
     * The previous video stream will be stopped.
     *
     * @param videoStream the video stream to publish.
     * @param opts the options to use when publishing the stream.
     */
    publishVideoStream: (videoStream: MediaStream, opts?: PublishOptions) => Promise<void>;
    /**
     * Starts publishing the given audio stream to the call.
     * The stream will be stopped if the user changes an input device, or if the user leaves the call.
     *
     * Consecutive calls to this method will replace the audio stream that is currently being published.
     * The previous audio stream will be stopped.
     *
     * @param audioStream the audio stream to publish.
     */
    publishAudioStream: (audioStream: MediaStream) => Promise<void>;
    /**
     * Starts publishing the given screen-share stream to the call.
     *
     * Consecutive calls to this method will replace the previous screen-share stream.
     * The previous screen-share stream will be stopped.
     *
     * @param screenShareStream the screen-share stream to publish.
     * @param opts the options to use when publishing the stream.
     */
    publishScreenShareStream: (screenShareStream: MediaStream, opts?: PublishOptions) => Promise<void>;
    /**
     * Stops publishing the given track type to the call, if it is currently being published.
     * Underlying track will be stopped and removed from the publisher.
     *
     * @param trackType the track type to stop publishing.
     * @param stopTrack if `true` the track will be stopped, else it will be just disabled
     */
    stopPublish: (trackType: TrackType, stopTrack?: boolean) => Promise<void>;
    /**
     * Notifies the SFU that a noise cancellation process has started.
     *
     * @internal
     */
    notifyNoiseCancellationStarting: () => Promise<void | import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<import("./gen/video/sfu/signal_rpc/signal").StartNoiseCancellationRequest, import("./gen/video/sfu/signal_rpc/signal").StartNoiseCancellationResponse> | undefined>;
    /**
     * Notifies the SFU that a noise cancellation process has stopped.
     *
     * @internal
     */
    notifyNoiseCancellationStopped: () => Promise<void | import("@protobuf-ts/runtime-rpc").FinishedUnaryCall<import("./gen/video/sfu/signal_rpc/signal").StopNoiseCancellationRequest, import("./gen/video/sfu/signal_rpc/signal").StopNoiseCancellationResponse> | undefined>;
    /**
     * Update track subscription configuration for one or more participants.
     * You have to create a subscription for each participant for all the different kinds of tracks you want to receive.
     * You can only subscribe for tracks after the participant started publishing the given kind of track.
     *
     * @param trackType the kind of subscription to update.
     * @param changes the list of subscription changes to do.
     * @param type the debounce type to use for the update.
     */
    updateSubscriptionsPartial: (trackType: VideoTrackType | 'video' | 'screen', changes: SubscriptionChanges, type?: DebounceType) => void;
    private updateSubscriptions;
    /**
     * Will enhance the reported stats with additional participant-specific information (`callStatsReport$` state [store variable](./StreamVideoClient.md/#readonlystatestore)).
     * This is usually helpful when detailed stats for a specific participant are needed.
     *
     * @param sessionId the sessionId to start reporting for.
     */
    startReportingStatsFor: (sessionId: string) => void | undefined;
    /**
     * Opposite of `startReportingStatsFor`.
     * Will turn off stats reporting for a specific participant.
     *
     * @param sessionId the sessionId to stop reporting for.
     */
    stopReportingStatsFor: (sessionId: string) => void | undefined;
    /**
     * Resets the last sent reaction for the user holding the given `sessionId`. This is a local action, it won't reset the reaction on the backend.
     *
     * @param sessionId the session id.
     */
    resetReaction: (sessionId: string) => void;
    /**
     * Sets the list of criteria to sort the participants by.
     *
     * @param criteria the list of criteria to sort the participants by.
     */
    setSortParticipantsBy: CallState['setSortParticipantsBy'];
    /**
     * Updates the list of video layers to publish.
     *
     * @internal
     * @param enabledLayers the list of layers to enable.
     */
    updatePublishQuality: (enabledLayers: VideoLayerSetting[]) => Promise<void | undefined>;
    private assertCallJoined;
    /**
     * Sends a reaction to the other call participants.
     *
     * @param reaction the reaction to send.
     */
    sendReaction: (reaction: SendReactionRequest) => Promise<SendReactionResponse>;
    /**
     * Blocks the user with the given `userId`.
     *
     * @param userId the id of the user to block.
     */
    blockUser: (userId: string) => Promise<BlockUserResponse>;
    /**
     * Unblocks the user with the given `userId`.
     *
     * @param userId the id of the user to unblock.
     */
    unblockUser: (userId: string) => Promise<UnblockUserResponse>;
    /**
     * Mutes the current user.
     *
     * @param type the type of the mute operation.
     */
    muteSelf: (type: TrackMuteType) => Promise<MuteUsersResponse> | undefined;
    /**
     * Mutes all the other participants.
     *
     * @param type the type of the mute operation.
     */
    muteOthers: (type: TrackMuteType) => Promise<MuteUsersResponse> | undefined;
    /**
     * Mutes the user with the given `userId`.
     *
     * @param userId the id of the user to mute.
     * @param type the type of the mute operation.
     */
    muteUser: (userId: string | string[], type: TrackMuteType) => Promise<MuteUsersResponse>;
    /**
     * Will mute all users in the call.
     *
     * @param type the type of the mute operation.
     */
    muteAllUsers: (type: TrackMuteType) => Promise<MuteUsersResponse>;
    /**
     * Starts recording the call
     */
    startRecording: (request?: StartRecordingRequest) => Promise<StartRecordingResponse>;
    /**
     * Stops recording the call
     */
    stopRecording: () => Promise<StopRecordingResponse>;
    /**
     * Starts the transcription of the call.
     *
     * @param request the request data.
     */
    startTranscription: (request?: StartTranscriptionRequest) => Promise<StartTranscriptionResponse>;
    /**
     * Stops the transcription of the call.
     */
    stopTranscription: () => Promise<StopTranscriptionResponse>;
    /**
     * Sends a `call.permission_request` event to all users connected to the call. The call settings object contains infomration about which permissions can be requested during a call (for example a user might be allowed to request permission to publish audio, but not video).
     */
    requestPermissions: (data: RequestPermissionRequest) => Promise<RequestPermissionResponse>;
    /**
     * Allows you to grant certain permissions to a user in a call.
     * The permissions are specific to the call experience and do not survive the call itself.
     *
     * Supported permissions that can be granted are:
     * - `send-audio`
     * - `send-video`
     * - `screenshare`
     *
     * @param userId the id of the user to grant permissions to.
     * @param permissions the permissions to grant.
     */
    grantPermissions: (userId: string, permissions: string[]) => Promise<UpdateUserPermissionsResponse>;
    /**
     * Allows you to revoke certain permissions from a user in a call.
     * The permissions are specific to the call experience and do not survive the call itself.
     *
     * Supported permissions that can be revoked are:
     * - `send-audio`
     * - `send-video`
     * - `screenshare`
     *
     * @param userId the id of the user to revoke permissions from.
     * @param permissions the permissions to revoke.
     */
    revokePermissions: (userId: string, permissions: string[]) => Promise<UpdateUserPermissionsResponse>;
    /**
     * Allows you to grant or revoke a specific permission to a user in a call. The permissions are specific to the call experience and do not survive the call itself.
     *
     * When revoking a permission, this endpoint will also mute the relevant track from the user. This is similar to muting a user with the difference that the user will not be able to unmute afterwards.
     *
     * Supported permissions that can be granted or revoked: `send-audio`, `send-video` and `screenshare`.
     *
     * `call.permissions_updated` event is sent to all members of the call.
     *
     */
    updateUserPermissions: (data: UpdateUserPermissionsRequest) => Promise<UpdateUserPermissionsResponse>;
    /**
     * Starts the livestreaming of the call.
     *
     * @param data the request data.
     * @param params the request params.
     */
    goLive: (data?: GoLiveRequest, params?: {
        notify?: boolean;
    }) => Promise<GoLiveResponse>;
    /**
     * Stops the livestreaming of the call.
     */
    stopLive: () => Promise<StopLiveResponse>;
    /**
     * Starts the broadcasting of the call.
     */
    startHLS: () => Promise<StartHLSBroadcastingResponse>;
    /**
     * Stops the broadcasting of the call.
     */
    stopHLS: () => Promise<StopHLSBroadcastingResponse>;
    /**
     * Updates the call settings or custom data.
     *
     * @param updates the updates to apply to the call.
     */
    update: (updates: UpdateCallRequest) => Promise<UpdateCallResponse>;
    /**
     * Ends the call. Once the call is ended, it cannot be re-joined.
     */
    endCall: () => Promise<EndCallResponse>;
    /**
     * Pins the given session to the top of the participants list.
     *
     * @param sessionId the sessionId to pin.
     */
    pin: (sessionId: string) => void;
    /**
     * Unpins the given session from the top of the participants list.
     *
     * @param sessionId the sessionId to unpin.
     */
    unpin: (sessionId: string) => void;
    /**
     * Pins the given session to the top of the participants list for everyone
     * in the call.
     * You can execute this method only if you have the `pin-for-everyone` capability.
     *
     * @param request the request object.
     */
    pinForEveryone: (request: PinRequest) => Promise<PinResponse>;
    /**
     * Unpins the given session from the top of the participants list for everyone
     * in the call.
     * You can execute this method only if you have the `pin-for-everyone` capability.
     *
     * @param request the request object.
     */
    unpinForEveryone: (request: UnpinRequest) => Promise<UnpinResponse>;
    /**
     * Query call members with filter query. The result won't be stored in call state.
     * @param request
     * @returns
     */
    queryMembers: (request?: Omit<QueryMembersRequest, 'type' | 'id'>) => Promise<QueryMembersResponse>;
    /**
     * Will update the call members.
     *
     * @param data the request data.
     */
    updateCallMembers: (data: UpdateCallMembersRequest) => Promise<UpdateCallMembersResponse>;
    /**
     * Schedules an auto-drop timeout based on the call settings.
     * Applicable only for ringing calls.
     */
    private scheduleAutoDrop;
    /**
     * Retrieves the list of recordings for the current call or call session.
     *
     * If `callSessionId` is provided, it will return the recordings for that call session.
     * Otherwise, all recordings for the current call will be returned.
     *
     * @param callSessionId the call session id to retrieve recordings for.
     */
    queryRecordings: (callSessionId?: string) => Promise<ListRecordingsResponse>;
    /**
     * Retrieves the list of transcriptions for the current call.
     *
     * @returns the list of transcriptions.
     */
    queryTranscriptions: () => Promise<ListTranscriptionsResponse>;
    /**
     * Retrieve call statistics for a particular call session (historical).
     * Here `callSessionID` is mandatory.
     *
     * @param callSessionID the call session ID to retrieve statistics for.
     * @returns The call stats.
     */
    getCallStats: (callSessionID: string) => Promise<GetCallStatsResponse>;
    /**
     * Submit user feedback for the call
     *
     * @param rating Rating between 1 and 5 denoting the experience of the user in the call
     * @param reason The reason/description for the rating
     * @param custom Custom data
     * @returns
     */
    submitFeedback: (rating: number, { reason, custom, }?: {
        reason?: string | undefined;
        custom?: Record<string, any> | undefined;
    }) => Promise<CollectUserFeedbackResponse>;
    /**
     * Sends a custom event to all call participants.
     *
     * @param payload the payload to send.
     */
    sendCustomEvent: (payload: {
        [key: string]: any;
    }) => Promise<SendEventResponse>;
    applyDeviceConfig: () => void;
    private initCamera;
    private initMic;
    /**
     * Will begin tracking the given element for visibility changes within the
     * configured viewport element (`call.setViewport`).
     *
     * @param element the element to track.
     * @param sessionId the session id.
     * @param trackType the video mode.
     */
    trackElementVisibility: <T extends HTMLElement>(element: T, sessionId: string, trackType: VideoTrackType) => () => void;
    /**
     * Sets the viewport element to track bound video elements for visibility.
     *
     * @param element the viewport element.
     */
    setViewport: <T extends HTMLElement>(element: T) => () => void;
    /**
     * Binds a DOM <video> element to the given session id.
     * This method will make sure that the video element will play
     * the correct video stream for the given session id.
     *
     * Under the hood, it would also keep track of the video element dimensions
     * and update the subscription accordingly in order to optimize the bandwidth.
     *
     * If a "viewport" is configured, the video element will be automatically
     * tracked for visibility and the subscription will be updated accordingly.
     *
     * @param videoElement the video element to bind to.
     * @param sessionId the session id.
     * @param trackType the kind of video.
     */
    bindVideoElement: (videoElement: HTMLVideoElement, sessionId: string, trackType: VideoTrackType) => (() => void) | undefined;
    /**
     * Binds a DOM <audio> element to the given session id.
     *
     * This method will make sure that the audio element will
     * play the correct audio stream for the given session id.
     *
     * @param audioElement the audio element to bind to.
     * @param sessionId the session id.
     * @param trackType the kind of audio.
     */
    bindAudioElement: (audioElement: HTMLAudioElement, sessionId: string, trackType?: AudioTrackType) => (() => void) | undefined;
    /**
     * Binds a DOM <img> element to this call's thumbnail (if enabled in settings).
     *
     * @param imageElement the image element to bind to.
     * @param opts options for the binding.
     */
    bindCallThumbnailElement: (imageElement: HTMLImageElement, opts?: {
        fallbackImageSource?: string;
    }) => () => void;
}
