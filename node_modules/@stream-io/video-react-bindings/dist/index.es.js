import { jsx, Fragment } from 'react/jsx-runtime';
import { createContext, useContext, useState, useEffect, useMemo } from 'react';
import i18next from 'i18next';
import { RxUtils, CallState } from '@stream-io/video-client';

const StreamCallContext = createContext(undefined);
/**
 * A provider for the call object.
 */
const StreamCallProvider = (props) => {
    const { call, children } = props;
    return (jsx(StreamCallContext.Provider, { value: call, children: children }));
};
/**
 * A hook to get the call object from the closest provider.
 */
const useCall = () => {
    return useContext(StreamCallContext);
};

const mapToRegistry = (translationsMap, namespace) => Object.entries(translationsMap).reduce((acc, [lng, translations]) => {
    acc[lng] = { [namespace]: translations };
    return acc;
}, {});

const DEFAULT_LANGUAGE = 'en';
const DEFAULT_NAMESPACE = 'stream-video';
const DEFAULT_CONFIG = {
    debug: false,
    currentLanguage: DEFAULT_LANGUAGE,
    fallbackLanguage: false,
};
const DEFAULT_TRANSLATIONS_REGISTRY = mapToRegistry({}, DEFAULT_NAMESPACE);
const defaultTranslationFunction = (key) => key;
class StreamI18n {
    /** Simple logger function */
    constructor(options = {}) {
        /** Translator function that converts the provided string into its equivalent in the current language. */
        this.t = defaultTranslationFunction;
        this.init = async () => {
            try {
                this.t = await this.i18nInstance.init();
            }
            catch (e) {
                console.error(`Failed to initialize translations: ${JSON.stringify(e)}`);
            }
            return this;
        };
        this.changeLanguage = async (language, onChange) => {
            if (!this._checkIsInitialized())
                return;
            // i18next detects the language, if none provided, but it is better
            // to show this detection here explicitly
            const browserLanguage = typeof window !== 'undefined' && window.navigator
                ? window.navigator.language
                : undefined;
            await this.i18nInstance.changeLanguage(language || browserLanguage);
            onChange?.(this.currentLanguage);
        };
        this.registerTranslationsForLanguage = ({ lng, translations, }) => {
            if (!this._checkIsInitialized())
                return;
            this.i18nInstance.addResourceBundle(lng, DEFAULT_NAMESPACE, translations, true, true);
        };
        this._checkIsInitialized = () => {
            if (!this.i18nInstance.isInitialized) {
                console.warn('I18n instance is not initialized. Call yourStreamI18nInstance.init().');
            }
            return this.i18nInstance.isInitialized;
        };
        const { debug = DEFAULT_CONFIG.debug, currentLanguage = DEFAULT_CONFIG.currentLanguage, fallbackLanguage = DEFAULT_CONFIG.fallbackLanguage, translationsOverrides, } = options;
        this.i18nInstance = i18next.createInstance({
            debug,
            defaultNS: DEFAULT_NAMESPACE,
            fallbackLng: fallbackLanguage,
            interpolation: { escapeValue: false },
            keySeparator: false,
            lng: currentLanguage,
            nsSeparator: false,
            parseMissingKeyHandler: (key) => {
                return key;
            },
            resources: DEFAULT_TRANSLATIONS_REGISTRY,
        });
        if (translationsOverrides) {
            this.i18nInstance.on('initialized', () => {
                Object.entries(translationsOverrides).forEach(([lng, translations]) => {
                    this.registerTranslationsForLanguage({ lng, translations });
                });
            });
        }
    }
    get currentLanguage() {
        this._checkIsInitialized();
        return this.i18nInstance.language;
    }
    get isInitialized() {
        return this.i18nInstance.isInitialized;
    }
}

const StreamI18nContext = createContext({
    t: defaultTranslationFunction,
});
const StreamI18nProvider = ({ children, ...createI18nParams }) => {
    const { i18n, t } = useCreateI18n(createI18nParams);
    return (jsx(StreamI18nContext.Provider, { value: { t, i18n }, children: children }));
};
const useCreateI18n = ({ i18nInstance, language, fallbackLanguage, translationsOverrides, }) => {
    const [i18n] = useState(() => i18nInstance ||
        new StreamI18n({
            currentLanguage: language,
            fallbackLanguage,
            translationsOverrides,
        }));
    const [t, setTranslationFn] = useState(() => defaultTranslationFunction);
    useEffect(() => {
        const { isInitialized } = i18n;
        if (!isInitialized) {
            i18n.init().then((_i18n) => setTranslationFn(() => _i18n.i18nInstance.t));
            return;
        }
        if (language && i18n?.currentLanguage !== language) {
            i18n.changeLanguage(language).catch((err) => {
                console.log('Error while changing language', err);
            });
        }
    }, [i18n, i18nInstance, language, translationsOverrides]);
    return { i18n, t };
};
const useI18n = () => useContext(StreamI18nContext);

const StreamVideoContext = createContext(undefined);
/**
 * StreamVideo is a provider component which should be used to wrap the entire application.
 * It provides the client object to all children components and initializes the i18n instance.
 *  @param PropsWithChildren<StreamVideoProps>
 *  @category Client State
 */
const StreamVideoProvider = ({ children, client, i18nInstance, language, translationsOverrides, }) => {
    return (jsx(StreamVideoContext.Provider, { value: client, children: jsx(StreamI18nProvider, { i18nInstance: i18nInstance, language: language, translationsOverrides: translationsOverrides, children: children }) }));
};
/**
 *
 * @returns
 *
 * @category Client State
 */
const useStreamVideoClient = () => {
    return useContext(StreamVideoContext);
};

/**
 * Utility hook which provides the current value of the given observable.
 * @internal
 *
 * @param observable$ the observable to read data from.
 * @param defaultValue a default value. Used when the observable data can't be read or emits an error.
 */
const useObservableValue = (observable$, defaultValue) => {
    const [value, setValue] = useState(() => {
        try {
            return RxUtils.getCurrentValue(observable$);
        }
        catch (err) {
            if (typeof defaultValue === 'undefined')
                throw err;
            return defaultValue;
        }
    });
    useEffect(() => {
        const subscription = observable$.subscribe({
            next: setValue,
            error: (err) => {
                console.log('An error occurred while reading an observable', err);
                if (defaultValue)
                    setValue(defaultValue);
            },
        });
        return () => {
            subscription.unsubscribe();
        };
    }, [defaultValue, observable$]);
    return value;
};

/**
 * Checks whether we are using React Native
 */
const isReactNative = () => {
    if (typeof navigator === 'undefined')
        return false;
    return navigator.product?.toLowerCase() === 'reactnative';
};

// kind-of memoized, used as a default value
const EMPTY_DEVICES_ARRAY = Object.freeze([]);
/**
 * Utility hook, which provides the current call's state.
 *
 * @category Call State
 */
const useCallState = () => {
    const call = useCall();
    // return an empty and unlinked CallState object if there is no call in the provider
    // this ensures that the hooks always return a value and many null checks can be avoided
    if (!call) {
        const message = 'You are using useCallState() outside a Call context. ' +
            'Please wrap your component in <StreamCall /> and provide a "call" instance.';
        console.warn(message);
        return new CallState();
    }
    return call.state;
};
/**
 * Utility hook which provides information whether the current call is being recorded. It will return `true` if the call is being recorded.
 *
 * @category Call State
 */
const useIsCallRecordingInProgress = () => {
    const { recording$ } = useCallState();
    return useObservableValue(recording$);
};
/**
 * Utility hook which provides information whether the current call is broadcasting.
 *
 * @category Call State
 */
const useIsCallHLSBroadcastingInProgress = () => {
    const { egress$ } = useCallState();
    const egress = useObservableValue(egress$);
    if (!egress)
        return false;
    return egress.broadcasting;
};
/**
 * Utility hook which provides information whether the current call is live.
 *
 * @category Call State
 */
const useIsCallLive = () => {
    const { backstage$ } = useCallState();
    const isBackstageOn = useObservableValue(backstage$);
    return !isBackstageOn;
};
/**
 * Returns the list of blocked users in the current call.
 */
const useCallBlockedUserIds = () => {
    const { blockedUserIds$ } = useCallState();
    return useObservableValue(blockedUserIds$);
};
/**
 * Returns the timestamp when this call was created.
 */
const useCallCreatedAt = () => {
    const { createdAt$ } = useCallState();
    return useObservableValue(createdAt$);
};
/**
 * Returns the timestamp when this call was ended.
 */
const useCallEndedAt = () => {
    const { endedAt$ } = useCallState();
    return useObservableValue(endedAt$);
};
/**
 * Returns the timestamp telling when the call is scheduled to start.
 */
const useCallStartsAt = () => {
    const { startsAt$ } = useCallState();
    return useObservableValue(startsAt$);
};
/**
 * Returns the timestamp when this call was updated.
 */
const useCallUpdatedAt = () => {
    const { updatedAt$ } = useCallState();
    return useObservableValue(updatedAt$);
};
/**
 * Returns the information about the call's creator.
 */
const useCallCreatedBy = () => {
    const { createdBy$ } = useCallState();
    return useObservableValue(createdBy$);
};
/**
 * Returns the call's custom data.
 */
const useCallCustomData = () => {
    const { custom$ } = useCallState();
    return useObservableValue(custom$);
};
/**
 * Returns the call's Egress information.
 */
const useCallEgress = () => {
    const { egress$ } = useCallState();
    return useObservableValue(egress$);
};
/**
 * Returns the call's Ingress information.
 */
const useCallIngress = () => {
    const { ingress$ } = useCallState();
    return useObservableValue(ingress$);
};
/**
 * Returns the data for the current call session.
 */
const useCallSession = () => {
    const { session$ } = useCallState();
    return useObservableValue(session$);
};
/**
 * Returns the call's settings.
 */
const useCallSettings = () => {
    const { settings$ } = useCallState();
    return useObservableValue(settings$);
};
/**
 * Returns whether the call has transcribing enabled.
 */
const useIsCallTranscribingInProgress = () => {
    const { transcribing$ } = useCallState();
    return useObservableValue(transcribing$);
};
/**
 * Returns information about the user who has marked this call as ended.
 */
const useCallEndedBy = () => {
    const { endedBy$ } = useCallState();
    return useObservableValue(endedBy$);
};
/**
 * Utility hook which provides a boolean indicating whether there is
 * a participant in the current call which shares their screen.
 *
 * @category Call State
 */
const useHasOngoingScreenShare = () => {
    const { hasOngoingScreenShare$ } = useCallState();
    return useObservableValue(hasOngoingScreenShare$);
};
/**
 * Utility hook which provides the latest stats report of the current call.
 *
 * The latest stats report of the current call.
 * When stats gathering is enabled, this observable will emit a new value
 * at a regular (configurable) interval.
 *
 * Consumers of this observable can implement their own batching logic
 * in case they want to show historical stats data.
 *
 * @category Call State
 */
const useCallStatsReport = () => {
    const { callStatsReport$ } = useCallState();
    return useObservableValue(callStatsReport$);
};
/**
 * Utility hook which provides the dominant speaker of the current call.
 *
 * @category Call State
 */
const useDominantSpeaker = () => {
    const { dominantSpeaker$ } = useCallState();
    return useObservableValue(dominantSpeaker$);
};
/**
 * Utility hook which provides a list of call members.
 *
 * @category Call State
 */
const useCallMembers = () => {
    const { members$ } = useCallState();
    return useObservableValue(members$);
};
/**
 * Utility hook providing the current calling state of the call. For example, `RINGING` or `JOINED`.
 *
 * @category Call State
 */
const useCallCallingState = () => {
    const { callingState$ } = useCallState();
    return useObservableValue(callingState$);
};
/**
 * Utility hook providing the actual start time of the current session.
 * Useful for calculating the call duration.
 *
 * @category Call State
 */
const useCallStartedAt = () => {
    const { startedAt$ } = useCallState();
    return useObservableValue(startedAt$);
};
/**
 * A hook which provides a list of all participants that have joined an active call.
 *
 * @category Call State
 *
 * @param options.sortBy - A comparator function to sort the participants by.
 * Make sure to memoize output of the `combineComparators` function
 * (or keep it out of component's scope if possible) before passing it down to this property.
 */
const useParticipants = ({ sortBy, } = {}) => {
    const { participants$ } = useCallState();
    const participants = useObservableValue(participants$);
    return useMemo(() => {
        if (sortBy) {
            return [...participants].sort(sortBy);
        }
        return participants;
    }, [participants, sortBy]);
};
/**
 * A hook which provides a StreamVideoLocalParticipant object.
 * It signals that I have joined a call.
 *
 * @category Call State
 */
const useLocalParticipant = () => {
    const { localParticipant$ } = useCallState();
    return useObservableValue(localParticipant$);
};
/**
 * A hook which provides a list of all other participants than me that have joined an active call.
 *
 * @category Call State
 */
const useRemoteParticipants = () => {
    const { remoteParticipants$ } = useCallState();
    return useObservableValue(remoteParticipants$);
};
/**
 * Returns the approximate participant count of the active call.
 * This includes the anonymous users as well, and it is computed on the server.
 *
 * @category Call State
 */
const useParticipantCount = () => {
    const { participantCount$ } = useCallState();
    return useObservableValue(participantCount$);
};
/**
 * Returns the approximate anonymous participant count of the active call.
 * The regular participants are not included in this count. It is computed on the server.
 *
 * @category Call State
 */
const useAnonymousParticipantCount = () => {
    const { anonymousParticipantCount$ } = useCallState();
    return useObservableValue(anonymousParticipantCount$);
};
/**
 * Returns the generated thumbnail of the current call, if enabled in settings.
 */
const useCallThumbnail = () => {
    const { thumbnails$ } = useCallState();
    return useObservableValue(thumbnails$);
};
/**
 * A hook which returns the local participant's own capabilities.
 */
const useOwnCapabilities = () => {
    const { ownCapabilities$ } = useCallState();
    return useObservableValue(ownCapabilities$);
};
/**
 * Hook that returns true if the local participant has all the given permissions.
 *
 * @param permissions the permissions to check.
 */
const useHasPermissions = (...permissions) => {
    const capabilities = useOwnCapabilities();
    return permissions.every((permission) => capabilities?.includes(permission));
};
/**
 * Returns the camera state of the current call.
 *
 * @category Camera Manager State
 *
 */
const useCameraState = () => {
    const call = useCall();
    const { camera } = call;
    const devices$ = useMemo(() => camera.listDevices(), [camera]);
    const { state } = camera;
    const status = useObservableValue(state.status$);
    const optimisticStatus = useObservableValue(state.optimisticStatus$);
    const direction = useObservableValue(state.direction$);
    const mediaStream = useObservableValue(state.mediaStream$);
    const selectedDevice = useObservableValue(state.selectedDevice$);
    const devices = useObservableValue(devices$, EMPTY_DEVICES_ARRAY);
    const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);
    const isMute = status !== 'enabled';
    const optimisticIsMute = optimisticStatus !== 'enabled';
    return {
        camera,
        status,
        optimisticStatus,
        isEnabled: status === 'enabled',
        direction,
        mediaStream,
        devices,
        hasBrowserPermission,
        selectedDevice,
        isMute,
        optimisticIsMute,
    };
};
/**
 * Returns the microphone state of the current call.
 *
 * @category Microphone Manager State
 */
const useMicrophoneState = () => {
    const call = useCall();
    const { microphone } = call;
    const devices$ = useMemo(() => microphone.listDevices(), [microphone]);
    const { state } = microphone;
    const status = useObservableValue(state.status$);
    const optimisticStatus = useObservableValue(state.optimisticStatus$);
    const mediaStream = useObservableValue(state.mediaStream$);
    const selectedDevice = useObservableValue(state.selectedDevice$);
    const devices = useObservableValue(devices$, EMPTY_DEVICES_ARRAY);
    const hasBrowserPermission = useObservableValue(state.hasBrowserPermission$);
    const isSpeakingWhileMuted = useObservableValue(state.speakingWhileMuted$);
    const isMute = status !== 'enabled';
    const optimisticIsMute = optimisticStatus !== 'enabled';
    return {
        microphone,
        status,
        optimisticStatus,
        isEnabled: status === 'enabled',
        mediaStream,
        devices,
        selectedDevice,
        hasBrowserPermission,
        isSpeakingWhileMuted,
        isMute,
        optimisticIsMute,
    };
};
/**
 * Returns the speaker state of the current call.
 *
 * Note: This hook is not supported in React Native
 */
const useSpeakerState = () => {
    if (isReactNative()) {
        throw new Error('This feature is not supported in React Native. Please visit https://getstream.io/video/docs/reactnative/core/camera-and-microphone/#speaker-management for more details');
    }
    const call = useCall();
    const { speaker } = call;
    const devices$ = useMemo(() => speaker.listDevices(), [speaker]);
    const devices = useObservableValue(devices$, EMPTY_DEVICES_ARRAY);
    const selectedDevice = useObservableValue(speaker.state.selectedDevice$);
    return {
        speaker,
        devices,
        selectedDevice,
        isDeviceSelectionSupported: speaker.state.isDeviceSelectionSupported,
    };
};
/**
 * Returns the Screen Share state of the current call.
 */
const useScreenShareState = () => {
    const call = useCall();
    const { screenShare } = call;
    const status = useObservableValue(screenShare.state.status$);
    const pendingStatus = useObservableValue(screenShare.state.optimisticStatus$);
    const mediaStream = useObservableValue(screenShare.state.mediaStream$);
    const isMute = status !== 'enabled';
    const optimisticStatus = pendingStatus ?? status;
    const optimisticIsMute = optimisticStatus !== 'enabled';
    return {
        screenShare,
        mediaStream,
        status,
        optimisticStatus,
        isMute,
        optimisticIsMute,
    };
};

var CallStateHooks = /*#__PURE__*/Object.freeze({
    __proto__: null,
    useAnonymousParticipantCount: useAnonymousParticipantCount,
    useCallBlockedUserIds: useCallBlockedUserIds,
    useCallCallingState: useCallCallingState,
    useCallCreatedAt: useCallCreatedAt,
    useCallCreatedBy: useCallCreatedBy,
    useCallCustomData: useCallCustomData,
    useCallEgress: useCallEgress,
    useCallEndedAt: useCallEndedAt,
    useCallEndedBy: useCallEndedBy,
    useCallIngress: useCallIngress,
    useCallMembers: useCallMembers,
    useCallSession: useCallSession,
    useCallSettings: useCallSettings,
    useCallStartedAt: useCallStartedAt,
    useCallStartsAt: useCallStartsAt,
    useCallState: useCallState,
    useCallStatsReport: useCallStatsReport,
    useCallThumbnail: useCallThumbnail,
    useCallUpdatedAt: useCallUpdatedAt,
    useCameraState: useCameraState,
    useDominantSpeaker: useDominantSpeaker,
    useHasOngoingScreenShare: useHasOngoingScreenShare,
    useHasPermissions: useHasPermissions,
    useIsCallHLSBroadcastingInProgress: useIsCallHLSBroadcastingInProgress,
    useIsCallLive: useIsCallLive,
    useIsCallRecordingInProgress: useIsCallRecordingInProgress,
    useIsCallTranscribingInProgress: useIsCallTranscribingInProgress,
    useLocalParticipant: useLocalParticipant,
    useMicrophoneState: useMicrophoneState,
    useOwnCapabilities: useOwnCapabilities,
    useParticipantCount: useParticipantCount,
    useParticipants: useParticipants,
    useRemoteParticipants: useRemoteParticipants,
    useScreenShareState: useScreenShareState,
    useSpeakerState: useSpeakerState
});

/**
 * Utility hook which provides access to client's state store.
 */
const useStore = () => {
    const client = useStreamVideoClient();
    if (!client) {
        throw new Error(`StreamVideoClient isn't initialized or this hook is called outside of <StreamVideo> context.`);
    }
    return client.readOnlyStateStore;
};
/**
 * Utility hook which provides a list of all notifications about created calls.
 * In the ring call settings, these calls can be outgoing (I have called somebody)
 * or incoming (somebody has called me).
 *
 * @category Client State
 */
const useCalls = () => {
    const { calls$ } = useStore();
    return useObservableValue(calls$);
};
/**
 * Returns the current connected user.
 *
 * @category Client State
 */
const useConnectedUser = () => {
    const { connectedUser$ } = useStore();
    return useObservableValue(connectedUser$);
};

/**
 * A hook-alike function that exposes all call state hooks.
 *
 * @category Call State
 */
const useCallStateHooks = () => CallStateHooks;

const Restricted = ({ canRequestOnly, hasPermissionsOnly, requiredGrants, requireAll = true, children, }) => {
    const call = useCall();
    const { useCallSettings, useOwnCapabilities } = useCallStateHooks();
    const ownCapabilities = useOwnCapabilities();
    const settings = useCallSettings();
    const hasPermissions = requiredGrants[requireAll ? 'every' : 'some']((capability) => ownCapabilities?.includes(capability));
    if (hasPermissionsOnly)
        return hasPermissions ? jsx(Fragment, { children: children }) : null;
    const canRequest = requiredGrants.some((capability) => call?.permissionsContext.canRequest(capability, settings));
    if (canRequestOnly)
        return canRequest ? jsx(Fragment, { children: children }) : null;
    if (hasPermissions || canRequest)
        return jsx(Fragment, { children: children });
    return null;
};

export { DEFAULT_LANGUAGE, DEFAULT_NAMESPACE, Restricted, StreamCallProvider, StreamI18n, StreamI18nProvider, StreamVideoProvider, defaultTranslationFunction, mapToRegistry, useCall, useCallStateHooks, useCalls, useConnectedUser, useCreateI18n, useI18n, useStore, useStreamVideoClient };
//# sourceMappingURL=index.es.js.map
